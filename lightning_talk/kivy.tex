\documentclass{beamer}
\usetheme{Malmoe}
\usepackage{minted}
\usepackage{hyperref}
\usepackage{listings}


\title[Kivy]{Kivy: a sweet new app development framework}

\begin{document}
%--- the titlepage frame -------------------------%
\begin{frame}[plain]
  \titlepage
\end{frame}


\begin{frame}{hey who let you in here}
Experience with mobile/desktop apps:

\pause
\begin{itemize}
  \item Kivy user since Saturday
  \pause
  \item I've used ETS (TraitsUI, Chaco) for numpy/scipy-type apps
  \pause
  \item Occasionally fiddle with Qt and friends: PyQT4, pyside
  \pause
  \item I tried to do something with pygame once but got bored
\end{itemize}
\end{frame}


\begin{frame}{the skinny}

\begin{itemize}
  \item Fast
    \pause
    \begin{itemize}
    \item graphics system implemented OpenGL ES 2.0
    \pause
    \item important bits written in C/Cython
    \end{itemize}
  \pause
  \item Simple: beautiful API
  \pause
  \item Multitouchtouchtouch
  \pause
  \item Crossplatform: Linux, Windows, OSX, Android
  \pause
  ...iOS (coming soon?)
  \pause
  \item License: LGPL3
\end{itemize}

\end{frame}


\begin{frame}{howsisworkthen?}

\begin{center}
  \includegraphics[height=.75\textheight]{architecture.png}
\end{center}

source: http://kivy.org/docs/guide/architecture.html

\end{frame}


\begin{frame}{widgets}
Widgets are...
\pause
\begin{itemize}
  \item anything you draw
  \pause
  \item anything you touch
  \pause
  \item anything you want to remember
  \pause
  \item trees
    \begin{itemize}
    \pause
    \item there's always at least one root widget
    \pause
    \item attach a widget: parent.add\_widget(child)
    \pause
    \item list widgets: parent.children == [child]
    \pause
    \item remove a widget: parent.remove\_widget(child) or parent.clear\_widgets()
    \pause
    \item remove all widgets: parent.clear\_widgets()
    \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{hello world}
  \inputminted{python}{hello_world.py}
\end{frame}


\begin{frame}{properties}
  Widgets can have properties. Properties are values you can bind callback functions to.
  \pause
  Examples:
    \begin{itemize}
    \item StringProperty
    \pause
    \item ListProperty
    \pause
    \item BooleanProperty
    \pause
    \item ObjectProperty
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{property example}
  \inputminted{python}{property_example.py}
\end{frame}


% \begin{frame}{final note on properties}
%   You can also register and dispatch custom events if you need to get fancy.
% \end{frame}


\begin{frame}{clock}
There's also a clock.
\pause
It does what you think it does.
\pause
\begin{itemize}
  \item schedule an event: clock.schedule\_once(some\_function, number\_of\_seconds)
  \pause
  \item schedule repeated events: clock.schedule\_interval(some\_function, number\_of\_seconds)
  \pause
\end{itemize}
\end{frame}


\begin{frame}{input... more input}
  When someone touches the screen or clicks the mouse on a widget,
  input events are automatically fired and dispatched to methods on
  the widget:
  \pause
  \begin{itemize}
  \item on\_touch\_down()
  \pause
  \item on\_touch\_move()
  \pause
  \item on\_touch\_up()
  \pause
\end{itemize}
If there are widgets on top of other widgets, the top-most widget can
choose to intercept the touch or pass it along.
\pause
So handling input is easy.
\end{frame}



% \begin{itemize}
%   \item
%   \pause
%   \item
% \end{itemize}


\begin{frame}[fragile]{graphics}
  Every widget has a canvas, and it works like this:
  \begin{minted}[linenos]{python}
    class Foo(Widget):
        def __init__(self, **kwargs):
            super(Foo, self).__init__(**kwargs)
            with self.canvas:
                # set color
                Color(1., 0., 0.)
                # draw stuff with primitives
                Rectangle(pos=(20, 30), size=(100, 100))
            # nevermind; erase what we just did
            self.canvas.clear()
  \end{minted}
\end{frame}


\begin{frame}{graphics}
  Canvas instructions get translated to OpenGL instructions.

  It's very snappy.

  \pause
  But when building something non-trivial, you end up having to keep
  tabs on lots of canvas state yourself.
\end{frame}


\begin{frame}[fragile]{kivy language (.kv)}
  Enter the kivy language.
  \begin{lstlisting}
  <Foo>:
      canvas:
          Color:
              rgb: 1., .0, .0
          Rectangle:
              pos: (20, 30)
              size: (100, 100)
  \end{lstlisting}

  Now widgets know how to draw themselves.
\end{frame}


\begin{frame}{stop}
  demo time
\end{frame}


\begin{frame}{other nicities}
  \begin{itemize}
  \item cache
  \pause
  \item vectors!
  \pause
  \item gesture recognition
  \end{itemize}
\end{frame}


\begin{frame}{[CITATION NEEDED]}

Kivy project:  \url{http://kivy.org}

Source: \url{http://github.com/kivy/kivy}

Code/presentation: \url{http://github.com/wilsaj/flingy}

\end{frame}


\begin{frame}{two men enter one man leaves}

contest: \url{http://kivy.org/\#contest}

\begin{itemize}
  \item make a game
  \item use Kivy + pure python - no custom C or C extensions
  \item put it on github
  \item registration deadline is Jan 25th - contest ends Jan 31st
  \item prizes: android tablets, github subscriptions, t-shirts
\end{itemize}
\end{frame}


\end{document}